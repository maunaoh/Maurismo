<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cuestionario Interactivo Mejorado</title>
    <!-- Carga de Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    
    <!-- Bloque de CSS Personalizado (Estilos) -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f9f5f7;
            color: #374151;
        }
        .quiz-container {
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }
        .answer-btn, .term-btn {
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            word-break: break-word;
            display: flex;
            align-items: center;
            gap: 0.75rem; /* 12px */
        }
        
        /* === Paleta de Colores Principal === */
        .correct { background-color: #059669 !important; color: white !important; border-color: #047857 !important; }
        .incorrect { background-color: #e11d48 !important; color: white !important; border-color: #be123c !important; }
        .selected-term { background-color: #6F1D45 !important; color: white !important; border: 2px solid #581736; transform: scale(1.02); font-weight: 600; }
        .selected-answer { background-color: #f3e8ee !important; border: 2px solid #6F1D45 !important; }
        .paired-item { background-color: #f3e8ee; color: #6F1D45; border: 1px dashed #c08497; }
        .paired-correct { background-color: #a7f3d0 !important; color: #064e3b !important; }
        .paired-incorrect { background-color: #fecdd3 !important; color: #881337 !important; }
        .disabled-final { cursor: not-allowed; opacity: 0.8; }

        /* === Estilos del Cronómetro y Puntos === */
        #timer-container { width: 180px; display: flex; flex-direction: column; align-items: center; }
        #clock-face { width: 150px; height: 150px; border: 8px solid #e5e7eb; border-radius: 50%; position: relative; display: flex; align-items: center; justify-content: center; background-color: white; transition: border-color 0.3s; }
        #clock-face.time-warning { border-color: #f59e0b; }
        #clock-hand { width: 4px; height: 60px; background-color: #6F1D45; position: absolute; bottom: 50%; left: calc(50% - 2px); transform-origin: bottom center; border-radius: 2px; transition: transform 1s linear; }
        #timer-text { font-size: 2.5rem; font-weight: 800; color: #6F1D45; z-index: 10; }
        #points-container { margin-top: 1rem; padding: 0.5rem 1rem; border: 2px solid #f3e8ee; border-radius: 8px; text-align: center; background-color: white; width: 150px; }
        #points-value { font-size: 1.5rem; font-weight: 700; color: #6F1D45; }

        /* === Estilos para Identificadores de Matching === */
        .letter-identifier {
            width: 2rem; height: 2rem; display: flex; align-items: center; justify-content: center;
            font-weight: 700; border-radius: 50%; background-color: #f3e8ee; color: #6F1D45;
            flex-shrink: 0;
        }
        .indicator-placeholder { width: 2rem; height: 2rem; flex-shrink: 0; }
        .match-indicator {
            width: 2rem; height: 2rem; display: flex; align-items: center; justify-content: center;
            font-weight: 700; border-radius: 50%; background-color: #6F1D45; color: white;
            transition: all 0.2s ease-in-out; transform: scale(0);
        }
        .match-indicator:not(:empty) { transform: scale(1); }
        .match-indicator.correct { background-color: #059669 !important; color: white !important; }
        .match-indicator.incorrect { background-color: #e11d48 !important; color: white !important; }
        
        /* === Estilos para Pregunta de Ordenar (Drag & Drop) === */
        .ordering-item {
            cursor: grab; user-select: none;
            display: flex; align-items: center; gap: 0.75rem;
            padding: 0.75rem; border-radius: 0.5rem;
            background-color: #e5e7eb; border: 1px solid #d1d5db;
        }
        .ordering-item.dragging { opacity: 0.5; background-color: #f3e8ee; border-color: #6F1D45; }
        .drag-handle { color: #9ca3af; margin-right: 0.5rem; cursor: grab; }
        
        @media (max-width: 768px) {
            .main-layout { flex-direction: column; align-items: center; }
            #timer-container { margin-bottom: 2rem; width: 100%; }
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">

    <div class="main-layout flex items-start justify-center gap-8 w-full max-w-5xl">

        <!-- Contenedor del Cronómetro y Puntos -->
        <div id="timer-container">
            <h3 class="text-xl font-bold text-[#6F1D45] mb-4">Tiempo</h3>
            <div id="clock-face">
                <div id="clock-hand"></div>
                <span id="timer-text">60</span>
            </div>
            <div id="points-container">
                <span class="text-sm font-medium text-gray-500">Valor</span>
                <p id="points-value">1.00</p>
            </div>
        </div>

        <!-- Contenedor principal del Quiz -->
        <div id="quiz-app" class="quiz-container bg-white p-8 rounded-xl w-full max-w-2xl relative">
            <h1 id="quiz-title" class="text-2xl font-bold text-center text-[#6F1D45] mb-4 border-b-2 pb-2 border-gray-200">
                <!-- El título se insertará aquí desde JS -->
            </h1>
            <div class="flex justify-center items-center mb-6">
                <p id="progress-display" class="text-md font-semibold text-gray-600"></p>
            </div>
            <div id="question-area">
                <h2 id="question-text" class="text-xl font-semibold mb-6 text-gray-800 text-center"></h2>
                <div id="answer-buttons" class="grid grid-cols-1 gap-4 relative"></div>
            </div>
            <div class="mt-8 text-center">
                <p id="feedback-message" class="mt-4 text-lg font-medium h-6"></p>
                <button id="submit-btn" class="hidden bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 px-6 rounded-full transition duration-300 ease-in-out mt-4 mr-4">Enviar Respuesta</button>
                <button id="next-btn" class="hidden bg-[#6F1D45] hover:bg-[#581736] text-white font-bold py-3 px-6 rounded-full transition duration-300 ease-in-out disabled:opacity-50 mt-4">Siguiente</button>
            </div>
        </div>
    </div>

    <!-- Bloque de JavaScript -->
    <script>
        // =========================================================================
        // 1. DATOS DEL QUIZ
        // =========================================================================
        const quizTitle = "Administración de la Producción: Pronósticos, capacidad y programación de operaciones.";
        const quizData = [
            { question: "¿Cuál es el objetivo principal de un modelo de pronóstico en operaciones?", type: "multiple_choice", points: 1, answers: [{ text: "Anticipar la demanda futura con base en datos históricos.", correct: true }, { text: "Anticipar los costos variables en base a datos anticipados.", correct: false }, { text: "Reducción de la fuerza laboral.", correct: false }, { text: "Automatizar todos los procesos", correct: false }] },
            { question: "¿Qué tipo de modelo de pronóstico es el más eficaz para estimar datos históricos que presentan una tendencia creciente o decreciente en el tiempo?", type: "multiple_choice", points: 1, answers: [{ text: "Promedio móvil.", correct: false }, { text: "Suavización exponencial doble.", correct: true }, { text: "Suavización exponencial simple.", correct: false }, { text: "Análisis de varianza.", correct: false }] },
            { question: "¿Cuál de los siguientes factores influye en la selección de un modelo de pronóstico?", type: "multiple_choice", points: 1, answers: [{ text: "Grado de detalle de la información.", correct: false }, { text: "Equipo de trabajo a emplear.", correct: false }, { text: "Número de periodos a evaluar.", correct: false }, { text: "Nivel de precisión requerido.", correct: true }] },
            { question: "¿Cómo se define la capacidad operativa dentro de una organización de servicios?", type: "multiple_choice", points: 1, answers: [{ text: "Número de piezas fabricadas.", correct: false }, { text: "Cantidad de clientes atendidos eficientemente.", correct: true }, { text: "Costo del producto por hora.", correct: false }, { text: "Tiempo total de producción.", correct: false }] },
            { question: "¿Cuál es el propósito estratégico de gestionar la capacidad operativa?", type: "multiple_choice", points: 1, answers: [{ text: "Maximizar el inventario.", correct: false }, { text: "Ajustes en la fuerza laboral.", correct: false }, { text: "Ajustar recursos para enfrentar variaciones en la demanda.", correct: true }, { text: "Influir en el mercado", correct: false }] },
            { question: "¿Qué herramienta gráfica permite visualizar de manera efectiva los niveles máximos de rendimiento que puede alcanzar un sistema operativo?", type: "multiple_choice", points: 1, answers: [{ text: "Gráfico de control.", correct: false }, { text: "Diagrama de Pareto.", correct: false }, { text: "Modelos de serie de tiempos.", correct: false }, { text: "Curva de aprendizaje.", correct: true }] },
            { question: "Es una de las principales particularidades operativas que distinguen a un sistema de producción intermitente.", type: "multiple_choice", points: 1, answers: [{ text: "Línea continua sin variaciones.", correct: false }, { text: "Operaciones estandarizadas y repetitivas.", correct: false }, { text: "Trabajo en lotes con reconfiguración frecuente.", correct: true }, { text: "Producción JUST IN TIME.", correct: false }] },
            { question: "Es un aspecto que distingue la programación con carga infinita respecto a la programación con carga finita.", type: "multiple_choice", points: 1, answers: [{ text: "La segunda se basa en simulaciones visuales.", correct: false }, { text: "La primera no considera límites de capacidad.", correct: true }, { text: "Ambas ignoran el tiempo de espera.", correct: false }, { text: "Ninguna relaciona operaciones con demanda.", correct: false }] },
            { question: "Es una técnica útil para establecer el orden de prioridades de producción.", type: "multiple_choice", points: 1, answers: [{ text: "Método FIFO o LIFO.", correct: true }, { text: "Índice de productividad.", correct: false }, { text: "Carga infinita.", correct: false }, { text: "Diagrama de Gantt.", correct: false }] },
            { question: "¿Qué implicaciones negativas puede generar la utilización de un modelo de pronóstico inadecuado en la gestión de las operaciones?", type: "multiple_choice", points: 1, answers: [{ text: "Optimiza los niveles de inventario sin intervención humana.", correct: false }, { text: "Mejora la sincronización entre producción y demanda.", correct: false }, { text: "Desajustes en la disponibilidad de recursos, producción y su programación.", correct: true }, { text: "Disminuye la necesidad de análisis de capacidad.", correct: false }] },
            { question: "¿Cuál es el objetivo principal de la Teoría de las Restricciones?", type: "multiple_choice", points: 1, answers: [{ text: "Identificar y explotar el recurso más limitante del sistema.", correct: true }, { text: "Reducir el número de trabajadores.", correct: false }, { text: "Desarrollar el enfoque holístico.", correct: false }, { text: "Influir sobre el entorno.", correct: false }] },
            { question: "Es el método que emplea la TOC para gestionar las restricciones.", type: "multiple_choice", points: 1, answers: [{ text: "Cinco pasos de enfoque.", correct: true }, { text: "Método de los cinco porqués.", correct: false }, { text: "Método de las 5´S.", correct: false }, { text: "Mantenimiento Total Productivo.", correct: false }] },
            { question: "¿Cómo se relaciona una restricción con el análisis de capacidad?", type: "multiple_choice", points: 1, answers: [{ text: "La restricción marca el límite superior de capacidad efectiva del sistema.", correct: true }, { text: "Las restricciones no afectan la capacidad.", correct: false }, { text: "Son elementos independientes en la planeación.", correct: false }, { text: "La restricción siempre incrementa la productividad.", correct: false }] },
            { question: "¿Cómo se vincula TOC con decisiones estratégicas de capacidad?", type: "multiple_choice", points: 1, answers: [{ text: "Elimina la necesidad de planeación.", correct: false }, { text: "Permite orientar la inversión en recursos críticos y evitar sobrecapacidad innecesaria.", correct: true }, { text: "Aplica sólo en áreas administrativas.", correct: false }, { text: "Reemplaza el análisis de demanda.", correct: false }] },
            { question: "¿Qué ocurre cuando se elimina una restricción?", type: "multiple_choice", points: 1, answers: [{ text: "El sistema deja de necesitar análisis.", correct: false }, { text: "Se incrementa automáticamente la rentabilidad.", correct: false }, { text: "Surge una nueva restricción que debe ser gestionada.", correct: true }, { text: "Se detiene la producción.", correct: false }] },
            { question: "Los pronósticos de largo plazo son utilizados principalmente por la alta gerencia para establecer el curso general de la organización.", type: "true_false", points: 1, answers: [{ text: "Verdadero", correct: true }, { text: "Falso", correct: false }] },
            { question: "Los métodos cuantitativos de pronóstico se aplican cuando no se dispone de datos históricos.", type: "true_false", points: 1, answers: [{ text: "Verdadero", correct: false }, { text: "Falso", correct: true }] },
            { question: "La suavización exponencial simple es adecuada cuando los datos presentan una tendencia marcada.", type: "true_false", points: 1, answers: [{ text: "Verdadero", correct: false }, { text: "Falso", correct: true }] },
            { question: "La capacidad diseñada es la producción real que se consigue en un periodo determinado.", type: "true_false", points: 1, answers: [{ text: "Verdadero", correct: false }, { text: "Falso", correct: true }] },
            { question: "El MAD (Desviación Absoluta Media) se calcula usando los valores al cuadrado de los errores.", type: "true_false", points: 1, answers: [{ text: "Verdadero", correct: false }, { text: "Falso", correct: true }] },
            { question: "En el promedio móvil ponderado, se asigna mayor peso a los datos más recientes.", type: "true_false", points: 1, answers: [{ text: "Verdadero", correct: true }, { text: "Falso", correct: false }] },
            { question: "La utilización se calcula como Capacidad Nominal entre Capacidad Diseñada.", type: "true_false", points: 1, answers: [{ text: "Verdadero", correct: true }, { text: "Falso", correct: false }] },
            { question: "El método Delphi es un ejemplo de pronóstico cuantitativo.", type: "true_false", points: 1, answers: [{ text: "Verdadero", correct: false }, { text: "Falso", correct: true }] },
            { question: "Las series de tiempo buscan descubrir un patrón en los datos históricos y luego extrapolarlo hacia el futuro.", type: "true_false", points: 1, answers: [{ text: "Verdadero", correct: true }, { text: "Falso", correct: false }] },
            { question: "La capacidad debe ser considerada en términos de volumen, tiempo y diversidad de producción planificada.", type: "true_false", points: 1, answers: [{ text: "Verdadero", correct: true }, { text: "Falso", correct: false }] },
            { question: "Es la estimación del valor futuro de una variable mediante la aplicación de métodos y procedimientos que contribuyan a reducir el margen de error, haciendo uso además del buen juicio y experiencia del responsable de realizar dicha estimación.", type: "multiple_choice", points: 1, answers: [{ text: "Planeación.", correct: false }, { text: "Pronóstico.", correct: true }, { text: "Visión.", correct: false }, { text: "Planificación.", correct: false }] },
            { question: "Todo pronóstico tiene implícito un margen de error.", type: "multiple_choice", points: 1, answers: [{ text: "Falla.", correct: false }, { text: "Incertidumbre.", correct: true }, { text: "Riesgo.", correct: false }, { text: "Contingencia.", correct: false }] },
            { question: "Un pronóstico a largo plazo se emplea para establecer el curso general de una organización para un plazo de 2 o 3 años y está orientado fundamentalmente a la alta gerencia.", type: "true_false", points: 1, answers: [{ text: "Verdadero", correct: true }, { text: "Falso", correct: false }] },
            { question: "Un pronóstico a corto plazo es utilizado para el diseño de tácticas y es usada por la administración intermedia y la administración de primera línea para cubrir necesidades en un futuro inmediato (semanas, días, horas, etc.)", type: "true_false", points: 1, answers: [{ text: "Verdadero", correct: true }, { text: "Falso", correct: false }] },
            { question: "Se pronostica el valor futuro de la variable basado en patrones establecidos en el pasado.", type: "multiple_choice", points: 1, answers: [{ text: "Modelos univariables para pronósticos.", correct: true }, { text: "Modelos causales.", correct: false }] },
            { question: "Relaciona la variable a pronosticar con una o más variables independientes.", type: "multiple_choice", points: 1, answers: [{ text: "Modelos univariables para pronósticos.", correct: false }, { text: "Modelos causales.", correct: true }] },
            { question: "Selecciona los modelos que son cualitativos.", type: "multiple_select", points: 5, answers: [{ text: "Suavización exponencial.", correct: false }, { text: "Análisis de regresión.", correct: false }, { text: "Proyección de tendencias.", correct: false }, { text: "Método de Delphi.", correct: true }, { text: "Juicio experto.", correct: true }, { text: "Promedio móvil doble.", correct: false }, { text: "Enfoques intuitivos.", correct: true }, { text: "Redacción de escenarios.", correct: true }, { text: "Promedio móvil ponderado.", correct: false }, { text: "Comparaciones técnicas.", correct: true }] },
            { question: "Selecciona los modelos que son cuantitativos.", type: "multiple_select", points: 5, answers: [{ text: "Suavización exponencial.", correct: true }, { text: "Análisis de regresión.", correct: true }, { text: "Proyección de tendencias.", correct: true }, { text: "Método de Delphi.", correct: false }, { text: "Juicio experto.", correct: false }, { text: "Promedio móvil doble.", correct: true }, { text: "Enfoques intuitivos.", correct: false }, { text: "Redacción de escenarios.", correct: false }, { text: "Promedio móvil ponderado.", correct: true }, { text: "Comparaciones técnicas.", correct: false }] },
            { question: "Los análisis de regresión se basan en el supuesto de que la variable que tratamos de pronosticar exhibe una relación de causa y efecto con una o más variables.", type: "true_false", points: 1, answers: [{ text: "Verdadero", correct: true }, { text: "Falso", correct: false }] },
            { question: "Los métodos cualitativos pueden aplicarse cuando la información sobre la variable que se está pronosticando no puede cuantificarse o son escasos.", type: "true_false", points: 1, answers: [{ text: "Verdadero", correct: true }, { text: "Falso", correct: false }] },
            { question: "Factores importantes para tomar en cuenta para establecer un pronóstico.", type: "multiple_select", points: 5, answers: [{ text: "Patrón de los datos.", correct: true }, { text: "Costo del pronóstico.", correct: true }, { text: "Cadena de suministro.", correct: false }, { text: "Exactitud deseada.", correct: true }, { text: "Administración del proyecto.", correct: false }, { text: "Disponibilidad de la información.", correct: true }, { text: "Diagrama de Ishikawa.", correct: false }, { text: "Facilidad de operar y entender.", correct: true }] },
            { question: "Ordena los pasos para desarrollar un sistema de pronósticos.", type: "ordering", points: 7, answers: [{text: "Determinar el uso del pronóstico."}, {text: "Seleccionar los aspectos que se deben pronosticar."}, {text: "Determinar el horizonte de tiempo del pronóstico."}, {text: "Seleccionar los modelos de pronóstico."}, {text: "Recopilar datos para elaborar el pronóstico."}, {text: "Realizar el pronóstico."}, {text: "Validar e implementar los resultados."}] },
            { question: "Haz el match correcto.", type: "matching", points: 4, matches: [{ term: "La tendencia.", match: "Es el movimiento gradual, hacia arriba o hacia abajo, de los datos en el tiempo." }, { term: "La estacionalidad.", match: "Es un patrón de datos que se repite después de un periodo de días, semanas, meses o trimestres." }, { term: "Los ciclos.", match: "Son patrones sujetos al ciclo comercial, detectados en los datos, que ocurren cada cierta cantidad de años." }, { term: "Las variaciones aleatorias.", match: "Son “señales” generadas en los datos por casualidad o por situaciones inusuales. No siguen ningún patrón discernible y, por lo tanto, no se pueden predecir." }] },
            { question: "Relaciona cada medida de error con su descripción correspondiente:", type: "matching", points: 4, matches: [{ term: "Desviación absoluta media (MAD)", match: "Técnica para determinar la precisión del modelo tomando el promedio de las desviaciones absolutas." }, { term: "Error cuadrático medio (MSE)", match: "Técnica para determinar la exactitud del modelo tomando el promedio de los cuadrados de los errores." }, { term: "Error porcentual absoluto medio (MAPE)", match: "Técnica para determinar la exactitud tomando el promedio de los errores absolutos como porcentaje de los valores observados." }, { term: "Porcentaje Medio de Error (MPE)", match: "Se calcula encontrando el error en cada periodo, dividiendo entre el valor real y promediando estos porcentajes." }] },
            { question: "Relaciona cada concepto con su definición correcta:", type: "matching", points: 4, matches: [{ term: "Constante de suavizamiento", match: "Valor entre 0 y 1 que se utiliza en el pronóstico de suavizamiento exponencial." }, { term: "Error de pronóstico o residual", match: "Es la diferencia entre un valor real y su valor de pronóstico." }, { term: "Modelos cualitativos", match: "Modelos que pronostican usando otras variables y factores, además del tiempo." }, { term: "Promedio móvil", match: "Técnica de pronósticos que promedia valores pasados (n) para calcular el pronóstico." }] },
            { question: "Relaciona los conceptos con el impacto del diseño de capacidad:", type: "matching", points: 3, matches: [{ term: "Manufactura", match: "Unidades producidas en un periodo determinado." }, { term: "Servicios", match: "Número de transacciones o clientes que pueden ser atendidos eficientemente." }, { term: "Capacidad", match: "Máximo nivel de valor agregado que cualquier sistema puede alcanzar en un tiempo específico." }] },
            { question: "Especialización y flexibilidad en la capacidad. Relaciona:", type: "matching", points: 3, matches: [{ term: "Fábrica enfocada", match: "Las instalaciones productivas son más eficientes cuando se especializan en un conjunto limitado de tareas o productos." }, { term: "Flexibilidad de la capacidad", match: "Permite adaptarse rápidamente a los cambios en la demanda del mercado y beneficiarse de las economías de alcance." }, { term: "Capacidad de respuesta", match: "Permite responder efectivamente a las fluctuaciones en el mercado y a reducir costos a través de la producción combinada de diferentes productos." }] },
            { question: "Relaciona los tipos de capacidad.", type: "matching", points: 3, matches: [{ term: "Capacidad diseñada", match: "Producción teórica máxima de un sistema en un periodo dado bajo condiciones ideales." }, { term: "Capacidad efectiva", match: "Capacidad que una empresa espera alcanzar dadas las restricciones operativas actuales." }, { term: "Capacidad nominal", match: "Producción real conseguida en un periodo determinado." }] },
            { question: "La eficiencia es la relación de la capacidad nominal entre la efectiva.", type: "true_false", points: 1, answers: [{ text: "Verdadero", correct: true }, { text: "Falso", correct: false }] },
            { question: "Son partes de la teoría de restricciones TOC.", type: "multiple_select", points: 5, answers: [{ text: "Identificar las restricciones del sistema.", correct: true }, { text: "Identificar la demanda del producto.", correct: false }, { text: "Explotar las restricciones del sistema.", correct: true }, { text: "Subordinar todo a la restricción anterior.", correct: true }, { text: "Elevar las restricciones del sistema.", correct: true }, { text: "Si se eliminó una restricción, debemos repetir el ciclo de TOC.", correct: true }, { text: "Reportar la eliminación de la restricción.", correct: false }] }
        ];

        // =========================================================================
        // 2. LÓGICA DEL QUIZ Y ESTADO
        // =========================================================================
        const quizTitleEl = document.getElementById('quiz-title'), questionText = document.getElementById('question-text'), answerButtons = document.getElementById('answer-buttons'), nextButton = document.getElementById('next-btn'), submitButton = document.getElementById('submit-btn'), feedbackMessage = document.getElementById('feedback-message'), progressDisplay = document.getElementById('progress-display'), clockFace = document.getElementById('clock-face'), clockHand = document.getElementById('clock-hand'), timerText = document.getElementById('timer-text'), pointsValue = document.getElementById('points-value');
        
        let currentQuestionIndex = 0, score = 0, totalPossibleScore = 0, shuffledQuizData = [], timer = null, timeLeft = 60, TIME_PER_QUESTION = 60;
        let activeTermSelection = null, activeMatchSelection = null, userPairs = new Map(), currentMatchingMatches = []; 

        function shuffleArray(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}}

        function startTimer() {
            clearInterval(timer); timeLeft = TIME_PER_QUESTION; clockFace.classList.remove('time-warning');
            clockHand.style.transition = 'none'; clockHand.style.transform = 'rotate(0deg)';
            void clockHand.offsetWidth; clockHand.style.transition = `transform 1s linear`;
            timerText.textContent = timeLeft;
            timer = setInterval(() => {
                timeLeft--; timerText.textContent = timeLeft;
                const degrees = ((TIME_PER_QUESTION - timeLeft) / TIME_PER_QUESTION) * 360;
                clockHand.style.transform = `rotate(${degrees}deg)`;
                if (timeLeft <= 10 && timeLeft > 0) clockFace.classList.add('time-warning');
                else if (timeLeft <= 0) timesUp();
            }, 1000);
        }

        function stopTimer(){clearInterval(timer)}
        
        function timesUp() {
            stopTimer(); feedbackMessage.textContent = '¡Tiempo agotado! ⌛';
            const qType = shuffledQuizData[currentQuestionIndex].type;
            if (qType === 'matching') submitMatchAnswer();
            else if (qType === 'multiple_select') submitMultipleSelectAnswer();
            else if (qType === 'ordering') submitOrderingAnswer();
            else {
                disableAllInteraction();
                Array.from(answerButtons.children).forEach(b => { if (b.dataset.correct === 'true') b.classList.add('correct'); });
                showNextButton(2000);
            }
        }
        
        function showNextButton(d=0){setTimeout(()=>{nextButton.classList.remove('hidden');nextButton.disabled=false;submitButton.classList.add('hidden')},d)}

        function startQuiz() {
            quizTitleEl.textContent = quizTitle;
            shuffledQuizData = [...quizData];
            shuffleArray(shuffledQuizData);
            currentQuestionIndex = 0; score = 0;
            totalPossibleScore = shuffledQuizData.reduce((sum, question) => sum + question.points, 0);
            nextButton.innerHTML = "Siguiente"; nextButton.classList.add('hidden');
            submitButton.classList.add('hidden'); feedbackMessage.textContent = '';
            questionText.classList.remove('hidden');
            showQuestion();
        }

        function resetState() {
            nextButton.classList.add('hidden'); submitButton.classList.add('hidden');
            feedbackMessage.textContent = '';
            answerButtons.className = 'grid grid-cols-1 gap-4 relative'; 
            const solutionContainer = document.getElementById('solution-container');
            if (solutionContainer) solutionContainer.remove();
            while (answerButtons.firstChild) answerButtons.removeChild(answerButtons.firstChild);
            activeTermSelection = null; activeMatchSelection = null; userPairs.clear(); currentMatchingMatches = [];
        }

        function showQuestion() {
            stopTimer(); resetState();
            const q = shuffledQuizData[currentQuestionIndex];
            progressDisplay.textContent = `Pregunta ${currentQuestionIndex + 1} de ${shuffledQuizData.length}`;
            questionText.textContent = q.question;
            pointsValue.textContent = `${q.points.toFixed(2)}`;
            
            if (q.type === 'matching') {
                showMatching(q); submitButton.textContent = 'Enviar Pares';
                submitButton.classList.remove('hidden'); submitButton.disabled = false;
            } else if (q.type === 'multiple_select') {
                if (q.answers.length > 6) answerButtons.className = 'grid grid-cols-2 gap-x-6 gap-y-4 relative';
                showMultipleSelect(q); submitButton.textContent = 'Enviar Selección';
                submitButton.classList.remove('hidden'); submitButton.disabled = false;
            } else if (q.type === 'ordering') {
                showOrdering(q); submitButton.textContent = 'Enviar Orden';
                submitButton.classList.remove('hidden'); submitButton.disabled = false;
            } else {
                showMultipleChoice(q);
            }
            startTimer();
        }

        function disableAllInteraction(){Array.from(answerButtons.children).forEach(b=>{b.disabled=true;b.classList.add('disabled-final');b.draggable=false;});submitButton.disabled=true}

        function showMultipleChoice(q) {
            q.answers.forEach(a => {
                const b = document.createElement('button'); b.textContent = a.text;
                b.classList.add('answer-btn','bg-gray-200','text-gray-800','font-medium','py-3','px-4','rounded-lg','text-left','hover:bg-gray-300','focus:outline-none','focus:ring-2','focus:ring-[#6F1D45]');
                if (a.correct) b.dataset.correct = a.correct;
                b.addEventListener('click', selectAnswer); answerButtons.appendChild(b);
            });
        }
        
        function selectAnswer(e) {
            stopTimer();
            const sb = e.currentTarget;
            const isC = sb.dataset.correct === 'true';
            const currentQuestion = shuffledQuizData[currentQuestionIndex];
            const points = currentQuestion.points;

            if (isC) {
                sb.classList.add('correct');
                feedbackMessage.textContent = `¡Correcto! ✅ (+${points.toFixed(2)} Puntos)`;
                score += points;
            } else {
                sb.classList.add('incorrect');
                feedbackMessage.textContent = 'Incorrecto. ❌';
            }
            disableAllInteraction();
            Array.from(answerButtons.children).forEach(b => { if (b.dataset.correct === 'true') b.classList.add('correct'); });
            showNextButton();
        }

        function showMultipleSelect(q) {
            q.answers.forEach(a => {
                const button = document.createElement('button');
                button.innerHTML = `<div class="w-6 h-6 border-2 border-gray-400 rounded-md flex items-center justify-center flex-shrink-0 transition-colors"><svg class="w-4 h-4 text-white hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"></path></svg></div><span class="flex-grow text-left">${a.text}</span>`;
                button.classList.add('answer-btn', 'bg-gray-200', 'text-gray-800', 'font-medium', 'py-3', 'px-4', 'rounded-lg', 'hover:bg-gray-300', 'focus:outline-none', 'focus:ring-2', 'focus:ring-[#6F1D45]');
                button.dataset.correct = a.correct;
                button.dataset.selected = 'false';
                button.addEventListener('click', toggleAnswerSelection);
                answerButtons.appendChild(button);
            });
        }

        function toggleAnswerSelection(e) {
            const button = e.currentTarget;
            const isSelected = button.dataset.selected === 'true';
            button.dataset.selected = String(!isSelected);
            button.classList.toggle('selected-answer');
            const checkbox = button.querySelector('div');
            const checkmark = button.querySelector('svg');
            checkbox.classList.toggle('bg-[#6F1D45]'); checkbox.classList.toggle('border-[#6F1D45]');
            checkmark.classList.toggle('hidden');
        }

        function submitMultipleSelectAnswer() {
            stopTimer(); disableAllInteraction(); submitButton.classList.add('hidden');
            const buttons = Array.from(answerButtons.children);
            const currentQuestion = shuffledQuizData[currentQuestionIndex];
            const totalCorrectOptions = currentQuestion.answers.filter(a => a.correct).length;
            let correctSelections = 0, incorrectSelections = 0;

            buttons.forEach(button => {
                const isCorrect = button.dataset.correct === 'true', isSelected = button.dataset.selected === 'true';
                if (isSelected && isCorrect) correctSelections++;
                else if (isSelected && !isCorrect) incorrectSelections++;
                if (isCorrect) button.classList.add('correct');
                if (isSelected && !isCorrect) button.classList.add('incorrect');
            });

            const questionPoints = currentQuestion.points;
            const pointsEarned = questionPoints * (Math.max(0, correctSelections - incorrectSelections) / totalCorrectOptions);
            score += pointsEarned > 0 ? pointsEarned : 0;
            feedbackMessage.textContent = `¡Respuesta evaluada! Ganaste ${pointsEarned > 0 ? pointsEarned.toFixed(2) : '0.00'} puntos.`;
            showNextButton();
        }
        
        function showOrdering(q) {
            let shuffledAnswers = [...q.answers];
            shuffleArray(shuffledAnswers);

            shuffledAnswers.forEach((answer, index) => {
                const item = document.createElement('div');
                item.draggable = true;
                item.dataset.text = answer.text; // Store original text for checking
                item.classList.add('ordering-item');
                item.innerHTML = `<svg class="drag-handle" width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 10H19M5 14H19" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
                <span class="flex-grow">${answer.text}</span>`;
                
                item.addEventListener('dragstart', () => item.classList.add('dragging'));
                item.addEventListener('dragend', () => item.classList.remove('dragging'));
                answerButtons.appendChild(item);
            });
            
            answerButtons.addEventListener('dragover', e => {
                e.preventDefault();
                const afterElement = getDragAfterElement(answerButtons, e.clientY);
                const dragging = document.querySelector('.dragging');
                if (afterElement == null) {
                    answerButtons.appendChild(dragging);
                } else {
                    answerButtons.insertBefore(dragging, afterElement);
                }
            });
        }
        
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.ordering-item:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        function submitOrderingAnswer() {
            stopTimer(); disableAllInteraction(); submitButton.classList.add('hidden');
            const currentQuestion = shuffledQuizData[currentQuestionIndex];
            const correctOrder = currentQuestion.answers.map(a => a.text);
            const userOrderItems = [...answerButtons.querySelectorAll('.ordering-item')];
            const userOrder = userOrderItems.map(item => item.dataset.text);
            let correctCount = 0;
            
            userOrder.forEach((text, index) => {
                if (text === correctOrder[index]) {
                    correctCount++;
                    userOrderItems[index].classList.add('correct');
                } else {
                    userOrderItems[index].classList.add('incorrect');
                }
            });

            const questionPoints = currentQuestion.points;
            const pointsEarned = (correctCount / correctOrder.length) * questionPoints;
            score += pointsEarned;
            feedbackMessage.textContent = `Acertaste ${correctCount} de ${correctOrder.length}. Ganaste ${pointsEarned.toFixed(2)} puntos.`;
            showNextButton();
        }

        function createMatchingButton(text, type, letter = '') {
            const button = document.createElement('button');
            button.classList.add('term-btn', 'bg-gray-200', 'text-gray-800', 'font-medium', 'p-3', 'rounded-lg', 'text-left', 'h-full', 'z-10');
            button.dataset.value = text; button.dataset.type = type;
            if (type === 'term') {
                button.dataset.letter = letter;
                button.innerHTML = `<div class="letter-identifier">${letter}</div><span class="flex-grow">${text}</span>`;
            } else {
                button.innerHTML = `<div class="indicator-placeholder"><div class="match-indicator"></div></div><span class="flex-grow">${text}</span>`;
            }
            button.addEventListener('click', handleMatchingSelection);
            return button;
        }

        function showMatching(q) {
            answerButtons.className = 'grid grid-cols-2 gap-x-8 gap-y-4 relative'; 
            const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split('');
            let terms = q.matches.map(m => m.term), matches = q.matches.map(m => m.match);
            currentMatchingMatches = q.matches; shuffleArray(matches); 
            for (let i = 0; i < terms.length; i++) {
                answerButtons.appendChild(createMatchingButton(terms[i], 'term', alphabet[i]));
                answerButtons.appendChild(createMatchingButton(matches[i], 'match'));
            }
        }
        
        function updateMatchIndicators() {
            const matchToTerm = new Map([...userPairs].map(([term, match]) => [match, term]));
            const termToLetter = new Map();
            Array.from(answerButtons.children).filter(btn => btn.dataset.type === 'term').forEach(btn => termToLetter.set(btn.dataset.value, btn.dataset.letter));
            Array.from(answerButtons.children).filter(btn => btn.dataset.type === 'match').forEach(matchBtn => {
                const indicator = matchBtn.querySelector('.match-indicator');
                const matchValue = matchBtn.dataset.value;
                if (matchToTerm.has(matchValue)) {
                    const termValue = matchToTerm.get(matchValue);
                    indicator.textContent = termToLetter.get(termValue);
                } else {
                    indicator.textContent = '';
                }
            });
        }

        function handleMatchingSelection(e) {
            const clickedBtn = e.currentTarget; const type = clickedBtn.dataset.type;
            if (clickedBtn.classList.contains('paired-item')) {
                const pVal=(type==='term')?userPairs.get(clickedBtn.dataset.value):Array.from(userPairs.entries()).find(([,m])=>m===clickedBtn.dataset.value)?.[0];
                if(pVal){
                    const pEl=Array.from(answerButtons.children).find(b=>b.dataset.value===pVal&&b!==clickedBtn);
                    clickedBtn.classList.remove('paired-item'); if(pEl)pEl.classList.remove('paired-item');
                    if(type==='term')userPairs.delete(clickedBtn.dataset.value); else Array.from(userPairs.entries()).forEach(([t,m])=>{if(m===clickedBtn.dataset.value)userPairs.delete(t)});
                    feedbackMessage.textContent='Par desvinculado.'; updateMatchIndicators(); return;
                }
            }
            let activeSel=(type==='term')?activeTermSelection:activeMatchSelection;
            if(activeSel)activeSel.classList.remove('selected-term');
            activeSel=(activeSel===clickedBtn)?null:clickedBtn;
            if(activeSel)activeSel.classList.add('selected-term');
            if(type==='term')activeTermSelection=activeSel; else activeMatchSelection=activeSel;
            if(activeTermSelection&&activeMatchSelection){
                const tVal=activeTermSelection.dataset.value, mVal=activeMatchSelection.dataset.value;
                Array.from(userPairs.entries()).forEach(([t,m])=>{if(t===tVal||m===mVal){const oT=Array.from(answerButtons.children).find(b=>b.dataset.type==='term'&&b.dataset.value===t),oM=Array.from(answerButtons.children).find(b=>b.dataset.type==='match'&&b.dataset.value===m);if(oT)oT.classList.remove('paired-item');if(oM)oM.classList.remove('paired-item');userPairs.delete(t)}});
                userPairs.set(tVal,mVal);
                activeTermSelection.classList.remove('selected-term','paired-item');activeTermSelection.classList.add('paired-item');
                activeMatchSelection.classList.remove('selected-term','paired-item');activeMatchSelection.classList.add('paired-item');
                feedbackMessage.textContent=`Par creado.`;
                activeTermSelection=null;activeMatchSelection=null;
                updateMatchIndicators();
            }
        }

        function submitMatchAnswer() {
            stopTimer(); disableAllInteraction(); submitButton.classList.add('hidden');
            const currentQuestion = shuffledQuizData[currentQuestionIndex];
            const questionPoints = currentQuestion.points;
            let correctPairs = 0; const totalPairs = currentMatchingMatches.length;
            const correctMap = new Map(currentMatchingMatches.map(p => [p.term, p.match]));
            userPairs.forEach((userMatch, userTerm) => {
                const isCorrect = correctMap.get(userTerm) === userMatch;
                const termBtn = Array.from(answerButtons.children).find(b => b.dataset.type === 'term' && b.dataset.value === userTerm);
                const matchBtn = Array.from(answerButtons.children).find(b => b.dataset.type === 'match' && b.dataset.value === userMatch);
                if (termBtn && matchBtn) {
                    termBtn.classList.remove('paired-item'); matchBtn.classList.remove('paired-item');
                    const indicator = matchBtn.querySelector('.match-indicator');
                    if (isCorrect) {
                        correctPairs++; termBtn.classList.add('paired-correct'); matchBtn.classList.add('paired-correct');
                        if (indicator) indicator.classList.add('correct');
                    } else {
                        termBtn.classList.add('paired-incorrect'); matchBtn.classList.add('paired-incorrect');
                        if (indicator) indicator.classList.add('incorrect');
                    }
                }
            });
            const pointsEarned = totalPairs > 0 ? (correctPairs / totalPairs) * questionPoints : 0;
            score += pointsEarned;
            feedbackMessage.textContent = pointsEarned === questionPoints ? '¡Emparejamiento perfecto! ✅' : `Acertaste ${correctPairs} de ${totalPairs}. Ganaste ${pointsEarned.toFixed(2)} puntos.`;
            showNextButton();
        }

        function showResult() {
            stopTimer(); resetState();
            questionText.classList.add('hidden');
            feedbackMessage.classList.add('text-2xl', 'font-bold', 'text-[#6F1D45]');
            feedbackMessage.textContent = `Puntaje final: ${score.toFixed(2)} de ${totalPossibleScore.toFixed(2)}.`;
            nextButton.innerHTML = "Jugar de Nuevo";
            nextButton.classList.remove('hidden');
            progressDisplay.textContent = 'Resultados';
        }

        function handleNextButton(){
            feedbackMessage.classList.remove('text-2xl', 'font-bold', 'text-[#6F1D45]');
            currentQuestionIndex++;
            if(currentQuestionIndex < shuffledQuizData.length){
                showQuestion();
            } else {
                showResult();
            }
        }
        
        nextButton.addEventListener('click',()=>{currentQuestionIndex < shuffledQuizData.length ? handleNextButton() : startQuiz()});
        
        submitButton.addEventListener('click', () => {
            const qType = shuffledQuizData[currentQuestionIndex].type;
            if (qType === 'matching') submitMatchAnswer();
            else if (qType === 'multiple_select') submitMultipleSelectAnswer();
            else if (qType === 'ordering') submitOrderingAnswer();
        });

        window.onload=startQuiz;
    </script>
</body>
</html>
